(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{374:function(t,e,l){"use strict";l.r(e);var a=l(44),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"第5章-链接"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#第5章-链接"}},[t._v("#")]),t._v(" 第5章 链接")]),t._v(" "),l("h2",{attrs:{id:"链接的概念与作用"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链接的概念与作用"}},[t._v("#")]),t._v(" 链接的概念与作用")]),t._v(" "),l("p",[t._v("链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。")]),t._v(" "),l("h2",{attrs:{id:"在ubuntu下链接的命令"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#在ubuntu下链接的命令"}},[t._v("#")]),t._v(" 在Ubuntu下链接的命令")]),t._v(" "),l("p",[t._v("ld命令用于链接，但是与gcc不同的是，ld命令需要用户给出链接需要的库。所以首先需要查找hello.c使用的库。\n使用gcc -m64 -no-pie -fno-PIC -Wall -Wextra --verbose hello.c -o hello.out，注意加了一个—verbose参数，用于显示gcc的具体流程。其中链接的部分如下图：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image030.png",alt:"图 29 gcc链接步骤"}})]),t._v(" "),l("p",[t._v("从上图可以找到链接时需要的库。比如动态链接库ld-linux-x86-64.so，静态链接库crt1.o等等。接下来可以使用ld命令进行链接。由于各个库已经位于环境变量中，所以可以将上图中各个库的绝对路径删减成文件名，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image031.png",alt:"图 30 ld命令链接"}})]),t._v(" "),l("p",[t._v("注意在链接时，由于各个库的依赖关系，不能随意调整文件的顺序。\n链接后，尝试运行。运行结果如下，可以看到ld命令使用没有问题：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image032.png",alt:"图 31 可执行文件hello.out"}})]),t._v(" "),l("h2",{attrs:{id:"可执行目标文件hello的格式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#可执行目标文件hello的格式"}},[t._v("#")]),t._v(" 可执行目标文件hello的格式")]),t._v(" "),l("h3",{attrs:{id:"可执行文件elf格式概述"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#可执行文件elf格式概述"}},[t._v("#")]),t._v(" 可执行文件ELF格式概述")]),t._v(" "),l("p",[t._v("使用readelf -a hello.out可以查看ELF格式。一个可执行文件的ELF格式结构如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image033.png",alt:"图 32 可执行文件ELF格式"}})]),t._v(" "),l("h3",{attrs:{id:"elf头分析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#elf头分析"}},[t._v("#")]),t._v(" ELF头分析")]),t._v(" "),l("p",[t._v("由readelf可以得到hello.out的ELF头如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image034.png",alt:"图 33 hello.out的ELF头"}})]),t._v(" "),l("p",[t._v("各部分解释如下，其中使用斜体突出显示了与图 20 hello.o的ELF头不同的部分：")]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"center"}},[t._v("项目")]),t._v(" "),l("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Magic")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("用于确定文件的类型或格式")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Class： ELF64")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("ELF64格式")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Data： 2's complement， little endian")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("二进制补码格式，小端")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Version： 1 (current)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("版本信息Version")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("OS/ABI： UNIX - System V")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("操作系统UNIX - System V")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("ABI Version： 0")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("ABI版本")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Type： EXEC (Executable file)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("可执行文件")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Machine： Advanced Micro Devices X86-64")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("Advanced Micro Devices X86-64的机器")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Version： 0x1")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("版本")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Entry point address： 0x4010f0")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("程序执行的入口地址")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Start of program headers： 64 (bytes into file)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("段头部表的开始")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Start of section headers： 14208 (bytes into file)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("节头部表的开始")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Flags： 0x0")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("一个标志位")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Size of this header： 64 (bytes)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("ELF头大小")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Size of program headers： 56 (bytes)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("段头部表大小")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Number of program headers： 12")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("几个段头部表")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Size of section headers： 64 (bytes)")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("节头部表大小")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Number of section headers： 27")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("节头部表数量")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Section header string table index： 26")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("字符串表在节头部表中的索引")])])])]),t._v(" "),l("p",[t._v("需要注意的是Type： EXEC (Executable file)项，指明这个程序是可执行程序，以及Entry point address： 0x4010f0项，指明这个程序的入口地址。")]),t._v(" "),l("h3",{attrs:{id:"节头表分析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#节头表分析"}},[t._v("#")]),t._v(" 节头表分析")]),t._v(" "),l("p",[t._v("readelf获得的节头表如下（由于节数量较多，只截取了一部分）：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image035.png",alt:"图 34 hello.out节头表"}})]),t._v(" "),l("p",[t._v("由于节数量较多，下表以.init节为例，列出了.init节的一些基本参数及其解释：")]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"center"}},[t._v("参数")]),t._v(" "),l("th",{staticStyle:{"text-align":"center"}},[t._v("意义")]),t._v(" "),l("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Address")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("0x401000")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Size")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("大小")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("0x1b")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Offset")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("偏移")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("0x1000")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Flag")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("权限标志位")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("AX(alloc + execute)")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"center"}},[t._v("Align")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("对齐")]),t._v(" "),l("td",{staticStyle:{"text-align":"center"}},[t._v("0x4")])])])]),t._v(" "),l("p",[t._v("从节头表中找到.text节的相关信息：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image036.png",alt:"图 35 hello.out的.text节信息"}})]),t._v(" "),l("p",[t._v("可以看到.text节的首地址是0x4010f0，正好与5.3.2 ELF头分析这部分中的Entry point address: 0x4010f0相等，如下图：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image037.png",alt:"图 36 hello.out的ELF头Entry point address信息"}})]),t._v(" "),l("h3",{attrs:{id:"其他节分析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#其他节分析"}},[t._v("#")]),t._v(" 其他节分析")]),t._v(" "),l("p",[t._v("使用readelf同样可以查看hello.out的其他节，由于与hello.o相差不大，此处只展示hello.out特有的动态节，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image038.png",alt:"图 37 hello.out动态节"}})]),t._v(" "),l("h2",{attrs:{id:"hello的虚拟地址空间"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#hello的虚拟地址空间"}},[t._v("#")]),t._v(" hello的虚拟地址空间")]),t._v(" "),l("p",[t._v("使用edb加载hello.out，如下图：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image039.png",alt:"图 38 edb加载hello.out"}})]),t._v(" "),l("p",[t._v("使用 edb 的 Data Dump 窗口查看加载到虚拟地址中的 hello 程序，如下图：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image040.png",alt:"图 39 edb的Data Dump功能"}})]),t._v(" "),l("p",[t._v("在 0x400000~0x401000 段中，程序被载入，从虚拟地址 0x400000 开始，到0x400fff 结束，排列如上图所示")]),t._v(" "),l("p",[t._v("使用readelf查看hello.out的程序头表，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image041.png",alt:"图 40 hello.out程序头表"}})]),t._v(" "),l("p",[t._v("在上图可以看出，程序包含 12 个段，其中：")]),t._v(" "),l("ol",[l("li",[t._v("PHDR保存程序头表。")]),t._v(" "),l("li",[t._v("INTERP指定在程序已经从可执行文件映射到内存之后，必须调用的解释器（如动态链接器）。")]),t._v(" "),l("li",[t._v("GNU_STACK：权限标志，标志栈是否是可执行的。")]),t._v(" "),l("li",[t._v("GNU_RELRO：指定在重定位结束之后那些内存区域是需要设置只读。")]),t._v(" "),l("li",[t._v("LOAD（4个）表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串）、程序的目标代码等。")]),t._v(" "),l("li",[t._v("DYNAMIC保存了由动态链接器使用的信息。")]),t._v(" "),l("li",[t._v("NOTE（2个）保存辅助信息。")])]),t._v(" "),l("h2",{attrs:{id:"链接的重定位过程分析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链接的重定位过程分析"}},[t._v("#")]),t._v(" 链接的重定位过程分析")]),t._v(" "),l("p",[t._v("使用objdump -d -r hello.out可以获取反汇编。使用grep命令可以查找出其中所有的函数，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image042.png",alt:"图 41 hello.out函数"}})]),t._v(" "),l("p",[t._v("可以看到hello.o的反汇编中只有一个main函数，如下")]),t._v(" "),l("p",[l("img",{attrs:{src:"image043.png",alt:"图 42 hello.o函数"}})]),t._v(" "),l("p",[t._v("因此可以得知，多余的函数都是在链接阶段，根据重定位条目添加的。以puts函数为例。hello.out的反汇编中，puts函数被调用的指令如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image044.png",alt:"图 43 hello.out调用puts"}})]),t._v(" "),l("p",[t._v("而hello.o的反汇编中，puts函数被调用时，前后的指令如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image045.png",alt:"图 44 hello.o调用puts"}})]),t._v(" "),l("p",[t._v("由上图可见，在链接之前的阶段中，puts函数只在重定位条目中有所体现。")]),t._v(" "),l("p",[t._v("根据图 44 hello.o调用puts开始从零分析。在图中0x1a位置有一个重定位条目与其对应，该条目位于.rodata节中，类型为R_X86_64_32（表示使用绝对地址）。使用readelf获取hello.o中该条重定位信息，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image046.png",alt:"图 45 hello.o重定位信息"}})]),t._v(" "),l("p",[t._v("根据这个条目可以分析出，要将.rodata + 0的地址传递给puts函数，作为参数。使用objdump -s -j .rodata hello.o获取hello.o的.rodata节，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image047.png",alt:"图 46 hello.o的.rodata节"}})]),t._v(" "),l("p",[t._v("可以看到，这正是printf的参数：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image048.png",alt:"图 47 hello.c中printf的参数"}})]),t._v(" "),l("p",[t._v("接下来，hello.o中0x1f位置又有一个重定位条目，类型为R_X86_64_PLT32（表示使用相对地址）。根据同一行的信息可以得知，此处为调用puts。通过类似图 45 hello.o重定位信息和图 46 hello.o的.rodata节中的查询方式也可以获得同样的信息。")]),t._v(" "),l("p",[l("img",{attrs:{src:"image049.png",alt:"图 48 hello.o的puts重定位条目"}})]),t._v(" "),l("p",[t._v("根据以上信息，链接器成功修正了puts的重定位信息，hello.out调用puts的方式如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image114.png",alt:"图 49 hello.out调用puts"}})]),t._v(" "),l("p",[t._v("由于是相对寻址的方式，0x401144处开始的四个字节，需要满足下图的结构：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image050.png",alt:"图 50 puts的相对寻址"}})]),t._v(" "),l("p",[t._v("同时，需要满足的地址关系是：")]),t._v(" "),l("p",[t._v("0x401148 (call下一条指令的地址) + XXXX(填充的4字节) = ADDR_PUTS")]),t._v(" "),l("p",[t._v("在确定了puts的位置之后，就可以通过此公式计算出需要填充的4个字节。从hello.out中可以找到puts的位置：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image051.png",alt:"图 51 hello.out中puts的地址"}})]),t._v(" "),l("p",[t._v("即ADDR_PUTS = 0x401090。所以XXXX = 0x401090 – 0x401148 = -0xb8。这四个字节是一个负数，需要转换为二进制补码，即：")]),t._v(" "),l("p",[t._v("-0xb8")]),t._v(" "),l("p",[t._v("= 1000 0000 … 1011 1000 (原码)")]),t._v(" "),l("p",[t._v("= 1111 1111 … 0100 0111 (反码)")]),t._v(" "),l("p",[t._v("= 1111 1111 … 0100 1000 (补码)")]),t._v(" "),l("p",[t._v("= 0xff ff ff 48。")]),t._v(" "),l("p",[t._v("由于是小端机器，转换成小端法可以得到48ffffff与图 49 hello.out调用puts中的结果相等。")]),t._v(" "),l("h2",{attrs:{id:"hello的执行流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#hello的执行流程"}},[t._v("#")]),t._v(" hello的执行流程")]),t._v(" "),l("p",[t._v("由于edb查看不方便，此处使用gdb追踪hello.out的执行流程。使用grep命令匹配hello.out中所有的函数，如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image052.png",alt:"图 52 hello.out所有函数"}})]),t._v(" "),l("p",[t._v("在gdb中对以上每个函数加断点：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image053.png",alt:"图 53 hello.out加断点"}})]),t._v(" "),l("p",[t._v("加断点后再运行，即可得知函数调用流程如下：")]),t._v(" "),l("ol",[l("li",[t._v("_init函数，位于0x401000")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image054.png",alt:"图 54 hello.out第一步"}})]),t._v(" "),l("ol",{attrs:{start:"2"}},[l("li",[t._v("_start函数，位于0x4010f0")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image055.png",alt:"图 55 hello.out第二步"}})]),t._v(" "),l("ol",{attrs:{start:"3"}},[l("li",[t._v("__libc_csu_init函数，位于0x4011c0")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image056.png",alt:"图 56 hello.out第三步"}})]),t._v(" "),l("ol",{attrs:{start:"4"}},[l("li",[t._v("_init函数，位于0x401000")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image057.png",alt:"图 57 hello.out第四步"}})]),t._v(" "),l("ol",{attrs:{start:"5"}},[l("li",[t._v("main函数，位于0x401125")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image058.png",alt:"图 58 hello.out第五步"}})]),t._v(" "),l("ol",{attrs:{start:"6"}},[l("li",[t._v("printf@plt函数，位于0x4010a0")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image059.png",alt:"图 59 hello.out第六步"}})]),t._v(" "),l("ol",{attrs:{start:"7"}},[l("li",[t._v("atoi@plt函数，位于0x4010c0")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image060.png",alt:"图 60 hello.out第七步"}})]),t._v(" "),l("ol",{attrs:{start:"8"}},[l("li",[t._v("sleep@plt函数，位于0x4010e0")])]),t._v(" "),l("p",[l("img",{attrs:{src:"image061.png",alt:"图 61 hello.out第八步"}})]),t._v(" "),l("ol",{attrs:{start:"9"}},[l("li",[l("p",[t._v("接下来进入for循环的8次重复，和6~8步相同")])]),t._v(" "),l("li",[l("p",[t._v("getchar@plt函数，位于0x4010b0")])])]),t._v(" "),l("p",[l("img",{attrs:{src:"image062.png",alt:"图 62 hello.out最后一步"}})]),t._v(" "),l("h2",{attrs:{id:"hello的动态链接分析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#hello的动态链接分析"}},[t._v("#")]),t._v(" Hello的动态链接分析")]),t._v(" "),l("p",[t._v("对于动态共享链接库中 PIC 函数，编译器没有办法预测函数的 运行时地址，所以需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表 PLT+全局偏移量表 GOT 实现函数的动态链接，GOT 中存放函数目标地址，PLT 使用 GOT 中地址跳转到目标函数。")]),t._v(" "),l("p",[t._v("关于PIC代码，一共有四种引用情况")]),t._v(" "),l("ol",[l("li",[l("p",[t._v("模块内的过程调用、跳转，采用PC相对偏移寻址")])]),t._v(" "),l("li",[l("p",[t._v("模块内数据访问，如模块内的全局变量和静态变量")])]),t._v(" "),l("li",[l("p",[t._v("模块外的过程调用、跳转")])]),t._v(" "),l("li",[l("p",[t._v("模块外的数据访问，如外部变量的访问")])])]),t._v(" "),l("p",[t._v("用readelf工具，在hello.out的节头表中可以找到GOT表：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image063.png",alt:"图 63 hello.out的GOT表"}})]),t._v(" "),l("p",[t._v("可以看到.got.plt位于0x404000处，内容如下：")]),t._v(" "),l("p",[l("img",{attrs:{src:"image064.png",alt:"图 64 hello.out的GOT表内容"}})]),t._v(" "),l("p",[t._v("函数调用时，首先跳转到 PLT 执行.plt 中逻辑，第一次访问跳转时GOT 地址为下一条指令，将函数序号压栈，然后跳转到 PLT[0]，在 PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写 GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数，这点和32位一样，32位是第一次开销很大，之后GOT[3]就有了地址，之后再引用的时候只需要一次就能从GOT[3]取出ext。")]),t._v(" "),l("h2",{attrs:{id:"本章小结"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#本章小结"}},[t._v("#")]),t._v(" 本章小结")]),t._v(" "),l("p",[t._v("本章通过对于hello.o进行动态编译，获得hello可执行文件，结合链接的概念及作用分析了链接对文本.o文件的相应处理，查看 hello 的 elf 格式并分析，详细地分析ELF头，重定位信息和段头部表的各部分详细含义，并对 objdump 得到的反汇编代码与 hello.s、hello.objdump 进行比较，了解链接时重定位等操作对于相关信息的，一些转换，并对结果进行了相应的解析。")])])}),[],!1,null,null,null);e.default=_.exports}}]);