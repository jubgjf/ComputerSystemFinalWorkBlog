<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第6章 hello进程管理 | Guan Jiannan 的计算机系统大作业博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.16f4c5d5.css" as="style"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/app.1b5451d3.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/2.a04b7fc9.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/15.145cf089.js" as="script"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/10.8c04925c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/11.3b6f4125.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/12.f7378424.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/13.3f64a882.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/14.0dc1b3d6.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/16.529c9f0a.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/17.e0fb3384.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/18.68e4c5ab.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/3.5219c653.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/4.0ed284d6.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/5.8b64aaec.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/6.744a911e.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/7.efae4d63.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/8.58d5c346.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/9.32b0a8f2.js">
    <link rel="stylesheet" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.16f4c5d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ComputerSystemFinalWorkBlog/" class="home-link router-link-active"><!----> <span class="site-name">Guan Jiannan 的计算机系统大作业博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>程序人生 - Hello’s P2P</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ComputerSystemFinalWorkBlog/" aria-current="page" class="sidebar-link">大作业说明</a></li><li><a href="/ComputerSystemFinalWorkBlog/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch1.html" class="sidebar-link">第1章 概述</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch2.html" class="sidebar-link">第2章 预处理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch3.html" class="sidebar-link">第3章 编译</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch4.html" class="sidebar-link">第4章 汇编</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch5.html" class="sidebar-link">第5章 链接</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch6.html" aria-current="page" class="active sidebar-link">第6章 hello 进程管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#进程的概念与作用" class="sidebar-link">进程的概念与作用</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#简述壳shell-bash的作用与处理流程" class="sidebar-link">简述壳Shell-bash的作用与处理流程</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#hello的fork进程创建过程" class="sidebar-link">Hello的fork进程创建过程</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#hello的execve过程" class="sidebar-link">Hello的execve过程</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#hello的进程执行" class="sidebar-link">Hello的进程执行</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#hello的异常与信号处理" class="sidebar-link">hello的异常与信号处理</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch6.html#本章小结" class="sidebar-link">本章小结</a></li></ul></li><li><a href="/ComputerSystemFinalWorkBlog/ch7.html" class="sidebar-link">第7章 hello 存储管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch8.html" class="sidebar-link">第8章 hello IO 管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/conclusion.html" class="sidebar-link">结论</a></li><li><a href="/ComputerSystemFinalWorkBlog/appendix.html" class="sidebar-link">附件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="header-anchor">#</a> 第6章 hello进程管理</h1> <h2 id="进程的概念与作用"><a href="#进程的概念与作用" class="header-anchor">#</a> 进程的概念与作用</h2> <p>进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。</p> <p>进程为用户提供了以下假象：我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。</p> <h2 id="简述壳shell-bash的作用与处理流程"><a href="#简述壳shell-bash的作用与处理流程" class="header-anchor">#</a> 简述壳Shell-bash的作用与处理流程</h2> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <p>Shell 是一个程序，是用户使用 Linux 的桥梁。Shell提供了一个界面，用户通过这个界面访问各个程序或操作系统内核的服务。</p> <h3 id="处理流程"><a href="#处理流程" class="header-anchor">#</a> 处理流程</h3> <ol><li>从终端读入输入的命令。</li> <li>将输入字符串切分获得所有的参数</li> <li>如果是内置命令则立即执行；否则调用相应的程序为其分配子进程并运行</li></ol> <p>shell 应该接受键盘输入信号，如Ctrl C，Ctrl Z等，并对这些信号进行相应处理。</p> <h2 id="hello的fork进程创建过程"><a href="#hello的fork进程创建过程" class="header-anchor">#</a> Hello的fork进程创建过程</h2> <p>在终端中键入 ./hello.out 1190200703 管健男 1：</p> <p><img src="image065.png" alt="图 65 运行hello.out"></p> <p>首先shell会对输入的命令行进行解析，因为 hello.out 不是一个内置的 shell 命令，所以解析之后shell判断用户的./hello.out命令的意图是执行当前目录下的可执行目标文件 hello.out。之后shell会调用 fork 函数创建一个新的运行的子进程。</p> <p><img src="image066.png" alt="图 66 shell调用hello.out的进程图"></p> <p>父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。父进程与子进程之间最大的区别在于它们拥有不同的 PID。在子进程执行期间，父进程默认选项是显示等待子进程的完成。新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。</p> <h2 id="hello的execve过程"><a href="#hello的execve过程" class="header-anchor">#</a> Hello的execve过程</h2> <p>execve 函数在当前进程的上下文中加载并运行可执行目标文件filename=hello，且带参数列表argv和环境变量列表envp，只有当出现错误时，例如找不到hello，execve 才会返回到调用程序，所以 execve 调用一次、从不返回。
argv变量指向一个以NULL结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例argv[0]是可执行目标文件的名字。环境变量列表也是由一个类似的数据结构表示的，envp变量指向一个以NULL结尾的指针数组，其中每个指针指向一个环境变量字符串，每个字符串都是形如”name=value”的“名-值”对。</p> <p><img src="image067.png" alt="图 67 execve函数加载效果"></p> <p>由于命令行键入了 ./hello.out 1190200703 管健男 1，所以argv分析如下：</p> <table><thead><tr><th style="text-align:center;">数组元素</th> <th style="text-align:center;">值</th></tr></thead> <tbody><tr><td style="text-align:center;">argv[0]</td> <td style="text-align:center;">./hello.out</td></tr> <tr><td style="text-align:center;">argv[1]</td> <td style="text-align:center;">1190200703</td></tr> <tr><td style="text-align:center;">argv[2]</td> <td style="text-align:center;">管健男</td></tr> <tr><td style="text-align:center;">argv[3]</td> <td style="text-align:center;">1</td></tr></tbody></table> <p>envp与shell的环境变量有关，在shell中（此处是bash）输入env，可以获得环境变量：</p> <p><img src="image068.png" alt="图 68 当前环境变量"></p> <p>execve加载了hello后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数的原型为：int main(int argc，char** argv，char** evnp)；</p> <h2 id="hello的进程执行"><a href="#hello的进程执行" class="header-anchor">#</a> Hello的进程执行</h2> <h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="header-anchor">#</a> 用户模式和内核模式</h3> <p>处理器通常使用一个寄存器提供用户模式和内核模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。
上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。</p> <p><img src="image069.png" alt="图 69 进程A、进程B之间的 上下文切换"></p> <h3 id="hello-out-的执行"><a href="#hello-out-的执行" class="header-anchor">#</a> hello.out 的执行</h3> <p>一开始hello.out正常顺序执行。当发生抢占时，则进行上下文切换。上下文切换是由内核中调度器完成的，当内核调度新的进程运行后，它就会抢占当前进程，并进行：</p> <ol><li>保存以前进程的上下文</li> <li>恢复新恢复进程被保存的上下文</li> <li>将控制传递给这个新恢复的进程</li></ol> <p>初始时，hello.out运行在用户模式，进程调用 sleep 之后，触发系统调用（陷阱），从而陷入内核模式，内核处理休眠请求主动释放当前进程，并将 hello.out进程从运行队列中移出加入等待队列，定时器开始计时1秒，内核进行上下文切换将当前进程的控制权交给其他进程。
当1秒后，定时器将发送一个中断信号，此时进入内核状态执行中断处理，将 hello.out 进程从等待队列中移出重新加入到运行队列，成为就绪状态，hello进程就可以继续进行自己的控制逻辑流了。</p> <p><img src="image070.png" alt="图 70 hello.out休眠1秒的进程调度"></p> <p>根据hello.c中的for循环，hello.out将不断重复上述过程。</p> <h2 id="hello的异常与信号处理"><a href="#hello的异常与信号处理" class="header-anchor">#</a> hello的异常与信号处理</h2> <h3 id="异常与信号处理概述"><a href="#异常与信号处理概述" class="header-anchor">#</a> 异常与信号处理概述</h3> <p>异常是控制流中的突变，用来响应处理器状态中的某些变化。状态变化被称为事件，事件可能与当前指令的执行直接相关。比如发生虚拟内存缺页、算术溢出，或者一条指令试图除零。另一方面，事件也可能和当前指令的执行没有关系，比如一个系统定时器产生的信号或者一个I/O请求完成。
在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子 程序(异常处理程序)。当异常处理程序完成处理后，根据引起异常的事件的类型 来决定是否返回，或返回到哪一条指令。
hello执行过程中可能出现四类异常：中断、陷阱、故障和终止。</p> <ol><li>中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。</li> <li>陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。</li></ol> <p><img src="image071.png" alt="图 71 陷阱的处理"></p> <ol start="3"><li>故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。</li></ol> <p><img src="image072.png" alt="图 72 故障的处理（以缺页为例）"></p> <ol start="4"><li>终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。</li></ol> <p><img src="image073.png" alt="图 73 终止的处理（以非法内存引用为例）"></p> <h3 id="hello-out执行过程中的异常和信号"><a href="#hello-out执行过程中的异常和信号" class="header-anchor">#</a> hello.out执行过程中的异常和信号</h3> <ol><li>随意按下键盘时</li></ol> <p><img src="image074.png" alt="图 74 随意按下键盘"></p> <p>此时程序正常执行。循环8次后，程序正常退出，被成功回收。ps结果如下：</p> <p><img src="image075.png" alt="图 75 hello进程被回收"></p> <p>在程序输出过程中按下 Ctrl Z：</p> <p><img src="image076.png" alt="图 76 按下Ctrl Z"></p> <ol start="2"><li>当按下Ctrl Z后</li></ol> <p>shell 作为父进程，收到SIGTSTP 信号，该信号处理函数的默认操作是打印屏幕回显，将hello进程挂起。
通过 ps 命令我们可以看出 hello 进程没有被回收，此时他的后台job号是1：</p> <p><img src="image077.png" alt="图 77 hello被挂起"></p> <p>调用 fg 1 将其调到前台，此时 shell 程序继续打印 hello 的输出：</p> <p><img src="image078.png" alt="图 78 hello调回前台"></p> <p>程序结束后，正常退出并被回收。</p> <ol start="3"><li>当按下Ctrl C后</li></ol> <p><img src="image079.png" alt="图 79 hello被终止"></p> <p>此时父进程收到 SIGINT 信号，信号处理函数的逻辑是终止 hello，并回收hello进程。</p> <h2 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h2> <p>本章节主要关注Shell如何运行 hello.out程序，以及对 hello.out进程执行过程的讨论。本章介绍了进程的概念与作用、 Shell及其工作流程，展示了fork函数如何创建新进程。之后展示了execve加载运hello程序的过程，以及 hello.out的进程执行过程，介绍进程时间片的概念、进程调度的过程、用户态与核心态的转换等。最后介绍了hello.out的异常与信号处理。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">9/25/2021, 4:41:50 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ComputerSystemFinalWorkBlog/ch5.html" class="prev">
        第5章 链接
      </a></span> <span class="next"><a href="/ComputerSystemFinalWorkBlog/ch7.html">
        第7章 hello 存储管理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ComputerSystemFinalWorkBlog/assets/js/app.1b5451d3.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/2.a04b7fc9.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/15.145cf089.js" defer></script>
  </body>
</html>
