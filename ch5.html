<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第5章 链接 | Guan Jiannan 的计算机系统大作业博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.9adedf70.css" as="style"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/app.38facb16.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/2.5a7b0d16.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/14.0dc1b3d6.js" as="script"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/10.8c04925c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/11.d95573f5.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/12.a4343f2d.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/13.3f64a882.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/15.fa58e624.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/16.d62808d3.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/17.e0fb3384.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/18.68e4c5ab.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/3.0d1cbe7f.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/4.1d52f60c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/5.8b64aaec.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/6.744a911e.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/7.efae4d63.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/8.58d5c346.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/9.32b0a8f2.js">
    <link rel="stylesheet" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.9adedf70.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ComputerSystemFinalWorkBlog/" class="home-link router-link-active"><!----> <span class="site-name">Guan Jiannan 的计算机系统大作业博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>程序人生 - Hello’s P2P</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ComputerSystemFinalWorkBlog/" aria-current="page" class="sidebar-link">大作业说明</a></li><li><a href="/ComputerSystemFinalWorkBlog/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch1.html" class="sidebar-link">第1章 概述</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch2.html" class="sidebar-link">第2章 预处理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch3.html" class="sidebar-link">第3章 编译</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch4.html" class="sidebar-link">第4章 汇编</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch5.html" aria-current="page" class="active sidebar-link">第5章 链接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#链接的概念与作用" class="sidebar-link">链接的概念与作用</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#在ubuntu下链接的命令" class="sidebar-link">在Ubuntu下链接的命令</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#可执行目标文件hello的格式" class="sidebar-link">可执行目标文件hello的格式</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#hello的虚拟地址空间" class="sidebar-link">hello的虚拟地址空间</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#链接的重定位过程分析" class="sidebar-link">链接的重定位过程分析</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#hello的执行流程" class="sidebar-link">hello的执行流程</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#hello的动态链接分析" class="sidebar-link">Hello的动态链接分析</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch5.html#本章小结" class="sidebar-link">本章小结</a></li></ul></li><li><a href="/ComputerSystemFinalWorkBlog/ch6.html" class="sidebar-link">第6章 hello 进程管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch7.html" class="sidebar-link">第7章 hello 存储管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch8.html" class="sidebar-link">第8章 hello IO 管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/conclusion.html" class="sidebar-link">结论</a></li><li><a href="/ComputerSystemFinalWorkBlog/appendix.html" class="sidebar-link">附件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第5章-链接"><a href="#第5章-链接" class="header-anchor">#</a> 第5章 链接</h1> <h2 id="链接的概念与作用"><a href="#链接的概念与作用" class="header-anchor">#</a> 链接的概念与作用</h2> <p>链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。</p> <h2 id="在ubuntu下链接的命令"><a href="#在ubuntu下链接的命令" class="header-anchor">#</a> 在Ubuntu下链接的命令</h2> <p>ld命令用于链接，但是与gcc不同的是，ld命令需要用户给出链接需要的库。所以首先需要查找hello.c使用的库。
使用gcc -m64 -no-pie -fno-PIC -Wall -Wextra --verbose hello.c -o hello.out，注意加了一个—verbose参数，用于显示gcc的具体流程。其中链接的部分如下图：</p> <p><img src="image030.png" alt="图 29 gcc链接步骤"></p> <p>从上图可以找到链接时需要的库。比如动态链接库ld-linux-x86-64.so，静态链接库crt1.o等等。接下来可以使用ld命令进行链接。由于各个库已经位于环境变量中，所以可以将上图中各个库的绝对路径删减成文件名，如下：</p> <p><img src="image031.png" alt="图 30 ld命令链接"></p> <p>注意在链接时，由于各个库的依赖关系，不能随意调整文件的顺序。
链接后，尝试运行。运行结果如下，可以看到ld命令使用没有问题：</p> <p><img src="image032.png" alt="图 31 可执行文件hello.out"></p> <h2 id="可执行目标文件hello的格式"><a href="#可执行目标文件hello的格式" class="header-anchor">#</a> 可执行目标文件hello的格式</h2> <h3 id="可执行文件elf格式概述"><a href="#可执行文件elf格式概述" class="header-anchor">#</a> 可执行文件ELF格式概述</h3> <p>使用readelf -a hello.out可以查看ELF格式。一个可执行文件的ELF格式结构如下：</p> <p><img src="image033.png" alt="图 32 可执行文件ELF格式"></p> <h3 id="elf头分析"><a href="#elf头分析" class="header-anchor">#</a> ELF头分析</h3> <p>由readelf可以得到hello.out的ELF头如下：</p> <p><img src="image034.png" alt="图 33 hello.out的ELF头"></p> <p>各部分解释如下，其中使用斜体突出显示了与图 20 hello.o的ELF头不同的部分：</p> <table><thead><tr><th style="text-align:center;">项目</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">Magic</td> <td style="text-align:center;">用于确定文件的类型或格式</td></tr> <tr><td style="text-align:center;">Class： ELF64</td> <td style="text-align:center;">ELF64格式</td></tr> <tr><td style="text-align:center;">Data： 2's complement， little endian</td> <td style="text-align:center;">二进制补码格式，小端</td></tr> <tr><td style="text-align:center;">Version： 1 (current)</td> <td style="text-align:center;">版本信息Version</td></tr> <tr><td style="text-align:center;">OS/ABI： UNIX - System V</td> <td style="text-align:center;">操作系统UNIX - System V</td></tr> <tr><td style="text-align:center;">ABI Version： 0</td> <td style="text-align:center;">ABI版本</td></tr> <tr><td style="text-align:center;">Type： EXEC (Executable file)</td> <td style="text-align:center;">可执行文件</td></tr> <tr><td style="text-align:center;">Machine： Advanced Micro Devices X86-64</td> <td style="text-align:center;">Advanced Micro Devices X86-64的机器</td></tr> <tr><td style="text-align:center;">Version： 0x1</td> <td style="text-align:center;">版本</td></tr> <tr><td style="text-align:center;">Entry point address： 0x4010f0</td> <td style="text-align:center;">程序执行的入口地址</td></tr> <tr><td style="text-align:center;">Start of program headers： 64 (bytes into file)</td> <td style="text-align:center;">段头部表的开始</td></tr> <tr><td style="text-align:center;">Start of section headers： 14208 (bytes into file)</td> <td style="text-align:center;">节头部表的开始</td></tr> <tr><td style="text-align:center;">Flags： 0x0</td> <td style="text-align:center;">一个标志位</td></tr> <tr><td style="text-align:center;">Size of this header： 64 (bytes)</td> <td style="text-align:center;">ELF头大小</td></tr> <tr><td style="text-align:center;">Size of program headers： 56 (bytes)</td> <td style="text-align:center;">段头部表大小</td></tr> <tr><td style="text-align:center;">Number of program headers： 12</td> <td style="text-align:center;">几个段头部表</td></tr> <tr><td style="text-align:center;">Size of section headers： 64 (bytes)</td> <td style="text-align:center;">节头部表大小</td></tr> <tr><td style="text-align:center;">Number of section headers： 27</td> <td style="text-align:center;">节头部表数量</td></tr> <tr><td style="text-align:center;">Section header string table index： 26</td> <td style="text-align:center;">字符串表在节头部表中的索引</td></tr></tbody></table> <p>需要注意的是Type： EXEC (Executable file)项，指明这个程序是可执行程序，以及Entry point address： 0x4010f0项，指明这个程序的入口地址。</p> <h3 id="节头表分析"><a href="#节头表分析" class="header-anchor">#</a> 节头表分析</h3> <p>readelf获得的节头表如下（由于节数量较多，只截取了一部分）：</p> <p><img src="image035.png" alt="图 34 hello.out节头表"></p> <p>由于节数量较多，下表以.init节为例，列出了.init节的一些基本参数及其解释：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th> <th style="text-align:center;">值</th></tr></thead> <tbody><tr><td style="text-align:center;">Address</td> <td style="text-align:center;">地址</td> <td style="text-align:center;">0x401000</td></tr> <tr><td style="text-align:center;">Size</td> <td style="text-align:center;">大小</td> <td style="text-align:center;">0x1b</td></tr> <tr><td style="text-align:center;">Offset</td> <td style="text-align:center;">偏移</td> <td style="text-align:center;">0x1000</td></tr> <tr><td style="text-align:center;">Flag</td> <td style="text-align:center;">权限标志位</td> <td style="text-align:center;">AX(alloc + execute)</td></tr> <tr><td style="text-align:center;">Align</td> <td style="text-align:center;">对齐</td> <td style="text-align:center;">0x4</td></tr></tbody></table> <p>从节头表中找到.text节的相关信息：</p> <p><img src="image036.png" alt="图 35 hello.out的.text节信息"></p> <p>可以看到.text节的首地址是0x4010f0，正好与5.3.2 ELF头分析这部分中的Entry point address: 0x4010f0相等，如下图：</p> <p><img src="image037.png" alt="图 36 hello.out的ELF头Entry point address信息"></p> <h3 id="其他节分析"><a href="#其他节分析" class="header-anchor">#</a> 其他节分析</h3> <p>使用readelf同样可以查看hello.out的其他节，由于与hello.o相差不大，此处只展示hello.out特有的动态节，如下：</p> <p><img src="image038.png" alt="图 37 hello.out动态节"></p> <h2 id="hello的虚拟地址空间"><a href="#hello的虚拟地址空间" class="header-anchor">#</a> hello的虚拟地址空间</h2> <p>使用edb加载hello.out，如下图：</p> <p><img src="image039.png" alt="图 38 edb加载hello.out"></p> <p>使用 edb 的 Data Dump 窗口查看加载到虚拟地址中的 hello 程序，如下图：</p> <p><img src="image040.png" alt="图 39 edb的Data Dump功能"></p> <p>在 0x400000~0x401000 段中，程序被载入，从虚拟地址 0x400000 开始，到0x400fff 结束，排列如上图所示</p> <p>使用readelf查看hello.out的程序头表，如下：</p> <p><img src="image041.png" alt="图 40 hello.out程序头表"></p> <p>在上图可以看出，程序包含 12 个段，其中：</p> <ol><li>PHDR保存程序头表。</li> <li>INTERP指定在程序已经从可执行文件映射到内存之后，必须调用的解释器（如动态链接器）。</li> <li>GNU_STACK：权限标志，标志栈是否是可执行的。</li> <li>GNU_RELRO：指定在重定位结束之后那些内存区域是需要设置只读。</li> <li>LOAD（4个）表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串）、程序的目标代码等。</li> <li>DYNAMIC保存了由动态链接器使用的信息。</li> <li>NOTE（2个）保存辅助信息。</li></ol> <h2 id="链接的重定位过程分析"><a href="#链接的重定位过程分析" class="header-anchor">#</a> 链接的重定位过程分析</h2> <p>使用objdump -d -r hello.out可以获取反汇编。使用grep命令可以查找出其中所有的函数，如下：</p> <p><img src="image042.png" alt="图 41 hello.out函数"></p> <p>可以看到hello.o的反汇编中只有一个main函数，如下</p> <p><img src="image043.png" alt="图 42 hello.o函数"></p> <p>因此可以得知，多余的函数都是在链接阶段，根据重定位条目添加的。以puts函数为例。hello.out的反汇编中，puts函数被调用的指令如下：</p> <p><img src="image044.png" alt="图 43 hello.out调用puts"></p> <p>而hello.o的反汇编中，puts函数被调用时，前后的指令如下：</p> <p><img src="image045.png" alt="图 44 hello.o调用puts"></p> <p>由上图可见，在链接之前的阶段中，puts函数只在重定位条目中有所体现。</p> <p>根据图 44 hello.o调用puts开始从零分析。在图中0x1a位置有一个重定位条目与其对应，该条目位于.rodata节中，类型为R_X86_64_32（表示使用绝对地址）。使用readelf获取hello.o中该条重定位信息，如下：</p> <p><img src="image046.png" alt="图 45 hello.o重定位信息"></p> <p>根据这个条目可以分析出，要将.rodata + 0的地址传递给puts函数，作为参数。使用objdump -s -j .rodata hello.o获取hello.o的.rodata节，如下：</p> <p><img src="image047.png" alt="图 46 hello.o的.rodata节"></p> <p>可以看到，这正是printf的参数：</p> <p><img src="image048.png" alt="图 47 hello.c中printf的参数"></p> <p>接下来，hello.o中0x1f位置又有一个重定位条目，类型为R_X86_64_PLT32（表示使用相对地址）。根据同一行的信息可以得知，此处为调用puts。通过类似图 45 hello.o重定位信息和图 46 hello.o的.rodata节中的查询方式也可以获得同样的信息。</p> <p><img src="image049.png" alt="图 48 hello.o的puts重定位条目"></p> <p>根据以上信息，链接器成功修正了puts的重定位信息，hello.out调用puts的方式如下：</p> <p><img src="image114.png" alt="图 49 hello.out调用puts"></p> <p>由于是相对寻址的方式，0x401144处开始的四个字节，需要满足下图的结构：</p> <p><img src="image050.png" alt="图 50 puts的相对寻址"></p> <p>同时，需要满足的地址关系是：</p> <p>0x401148 (call下一条指令的地址) + XXXX(填充的4字节) = ADDR_PUTS</p> <p>在确定了puts的位置之后，就可以通过此公式计算出需要填充的4个字节。从hello.out中可以找到puts的位置：</p> <p><img src="image051.png" alt="图 51 hello.out中puts的地址"></p> <p>即ADDR_PUTS = 0x401090。所以XXXX = 0x401090 – 0x401148 = -0xb8。这四个字节是一个负数，需要转换为二进制补码，即：</p> <p>-0xb8</p> <p>= 1000 0000 … 1011 1000 (原码)</p> <p>= 1111 1111 … 0100 0111 (反码)</p> <p>= 1111 1111 … 0100 1000 (补码)</p> <p>= 0xff ff ff 48。</p> <p>由于是小端机器，转换成小端法可以得到48ffffff与图 49 hello.out调用puts中的结果相等。</p> <h2 id="hello的执行流程"><a href="#hello的执行流程" class="header-anchor">#</a> hello的执行流程</h2> <p>由于edb查看不方便，此处使用gdb追踪hello.out的执行流程。使用grep命令匹配hello.out中所有的函数，如下：</p> <p><img src="image052.png" alt="图 52 hello.out所有函数"></p> <p>在gdb中对以上每个函数加断点：</p> <p><img src="image053.png" alt="图 53 hello.out加断点"></p> <p>加断点后再运行，即可得知函数调用流程如下：</p> <ol><li>_init函数，位于0x401000</li></ol> <p><img src="image054.png" alt="图 54 hello.out第一步"></p> <ol start="2"><li>_start函数，位于0x4010f0</li></ol> <p><img src="image055.png" alt="图 55 hello.out第二步"></p> <ol start="3"><li>__libc_csu_init函数，位于0x4011c0</li></ol> <p><img src="image056.png" alt="图 56 hello.out第三步"></p> <ol start="4"><li>_init函数，位于0x401000</li></ol> <p><img src="image057.png" alt="图 57 hello.out第四步"></p> <ol start="5"><li>main函数，位于0x401125</li></ol> <p><img src="image058.png" alt="图 58 hello.out第五步"></p> <ol start="6"><li>printf@plt函数，位于0x4010a0</li></ol> <p><img src="image059.png" alt="图 59 hello.out第六步"></p> <ol start="7"><li>atoi@plt函数，位于0x4010c0</li></ol> <p><img src="image060.png" alt="图 60 hello.out第七步"></p> <ol start="8"><li>sleep@plt函数，位于0x4010e0</li></ol> <p><img src="image061.png" alt="图 61 hello.out第八步"></p> <ol start="9"><li><p>接下来进入for循环的8次重复，和6~8步相同</p></li> <li><p>getchar@plt函数，位于0x4010b0</p></li></ol> <p><img src="image062.png" alt="图 62 hello.out最后一步"></p> <h2 id="hello的动态链接分析"><a href="#hello的动态链接分析" class="header-anchor">#</a> Hello的动态链接分析</h2> <p>对于动态共享链接库中 PIC 函数，编译器没有办法预测函数的 运行时地址，所以需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表 PLT+全局偏移量表 GOT 实现函数的动态链接，GOT 中存放函数目标地址，PLT 使用 GOT 中地址跳转到目标函数。</p> <p>关于PIC代码，一共有四种引用情况</p> <ol><li><p>模块内的过程调用、跳转，采用PC相对偏移寻址</p></li> <li><p>模块内数据访问，如模块内的全局变量和静态变量</p></li> <li><p>模块外的过程调用、跳转</p></li> <li><p>模块外的数据访问，如外部变量的访问</p></li></ol> <p>用readelf工具，在hello.out的节头表中可以找到GOT表：</p> <p><img src="image063.png" alt="图 63 hello.out的GOT表"></p> <p>可以看到.got.plt位于0x404000处，内容如下：</p> <p><img src="image064.png" alt="图 64 hello.out的GOT表内容"></p> <p>函数调用时，首先跳转到 PLT 执行.plt 中逻辑，第一次访问跳转时GOT 地址为下一条指令，将函数序号压栈，然后跳转到 PLT[0]，在 PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写 GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数，这点和32位一样，32位是第一次开销很大，之后GOT[3]就有了地址，之后再引用的时候只需要一次就能从GOT[3]取出ext。</p> <h2 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h2> <p>本章通过对于hello.o进行动态编译，获得hello可执行文件，结合链接的概念及作用分析了链接对文本.o文件的相应处理，查看 hello 的 elf 格式并分析，详细地分析ELF头，重定位信息和段头部表的各部分详细含义，并对 objdump 得到的反汇编代码与 hello.s、hello.objdump 进行比较，了解链接时重定位等操作对于相关信息的，一些转换，并对结果进行了相应的解析。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">6/23/2021, 2:15:04 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ComputerSystemFinalWorkBlog/ch4.html" class="prev">
        第4章 汇编
      </a></span> <span class="next"><a href="/ComputerSystemFinalWorkBlog/ch6.html">
        第6章 hello 进程管理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ComputerSystemFinalWorkBlog/assets/js/app.38facb16.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/2.5a7b0d16.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/14.0dc1b3d6.js" defer></script>
  </body>
</html>
