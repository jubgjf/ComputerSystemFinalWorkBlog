<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第4章 汇编 | Guan Jiannan 的计算机系统大作业博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.9adedf70.css" as="style"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/app.38facb16.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/2.5a7b0d16.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/13.3f64a882.js" as="script"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/10.8c04925c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/11.d95573f5.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/12.a4343f2d.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/14.0dc1b3d6.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/15.fa58e624.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/16.d62808d3.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/17.e0fb3384.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/18.68e4c5ab.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/3.0d1cbe7f.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/4.1d52f60c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/5.8b64aaec.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/6.744a911e.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/7.efae4d63.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/8.58d5c346.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/9.32b0a8f2.js">
    <link rel="stylesheet" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.9adedf70.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ComputerSystemFinalWorkBlog/" class="home-link router-link-active"><!----> <span class="site-name">Guan Jiannan 的计算机系统大作业博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>程序人生 - Hello’s P2P</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ComputerSystemFinalWorkBlog/" aria-current="page" class="sidebar-link">大作业说明</a></li><li><a href="/ComputerSystemFinalWorkBlog/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch1.html" class="sidebar-link">第1章 概述</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch2.html" class="sidebar-link">第2章 预处理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch3.html" class="sidebar-link">第3章 编译</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch4.html" aria-current="page" class="active sidebar-link">第4章 汇编</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch4.html#汇编的概念与作用" class="sidebar-link">汇编的概念与作用</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch4.html#在ubuntu下汇编的命令" class="sidebar-link">在Ubuntu下汇编的命令</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch4.html#可重定位目标elf格式" class="sidebar-link">可重定位目标elf格式</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch4.html#hello-o的结果解析" class="sidebar-link">Hello.o的结果解析</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch4.html#本章小结" class="sidebar-link">本章小结</a></li></ul></li><li><a href="/ComputerSystemFinalWorkBlog/ch5.html" class="sidebar-link">第5章 链接</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch6.html" class="sidebar-link">第6章 hello 进程管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch7.html" class="sidebar-link">第7章 hello 存储管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch8.html" class="sidebar-link">第8章 hello IO 管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/conclusion.html" class="sidebar-link">结论</a></li><li><a href="/ComputerSystemFinalWorkBlog/appendix.html" class="sidebar-link">附件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第4章-汇编"><a href="#第4章-汇编" class="header-anchor">#</a> 第4章 汇编</h1> <h2 id="汇编的概念与作用"><a href="#汇编的概念与作用" class="header-anchor">#</a> 汇编的概念与作用</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>把汇编语言翻译成机器语言的过程称为汇编。</p> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <p>汇编器（如as等）将汇编代码翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在二进制目标文件中。</p> <h2 id="在ubuntu下汇编的命令"><a href="#在ubuntu下汇编的命令" class="header-anchor">#</a> 在Ubuntu下汇编的命令</h2> <p>使用gcc -c进行汇编，如图</p> <p><img src="image019.png" alt="图 18 汇编"></p> <p>使用反汇编objdump -d来查看目标文件内容，示例如下</p> <p><img src="image020.png" alt="图 19 汇编结果示例"></p> <h2 id="可重定位目标elf格式"><a href="#可重定位目标elf格式" class="header-anchor">#</a> 可重定位目标elf格式</h2> <h3 id="elf格式分析综述"><a href="#elf格式分析综述" class="header-anchor">#</a> ELF格式分析综述</h3> <p>可重定位目标ELF格式结构如下：</p> <table><thead><tr><th style="text-align:center;">ELF头</th> <th style="text-align:center;">字段 e_entry 给出程序时第一条指令的地址</th></tr></thead> <tbody><tr><td style="text-align:center;">.text节</td> <td style="text-align:center;">已编译程序的机器代码</td></tr> <tr><td style="text-align:center;">.rodata节</td> <td style="text-align:center;">只读数据，比如 printf 语句中的格式串和开关语句的跳转表</td></tr> <tr><td style="text-align:center;">.data节</td> <td style="text-align:center;">已初始化的全局和静态 C 变量</td></tr> <tr><td style="text-align:center;">.bss节</td> <td style="text-align:center;">未初始化的全局和静态 C 变量</td></tr> <tr><td style="text-align:center;">.symtab节</td> <td style="text-align:center;">存放程序中定义和引用的函数和全局变量信息</td></tr> <tr><td style="text-align:center;">.rel.text节</td> <td style="text-align:center;">一个.text节中位置的列表，链接时修改</td></tr> <tr><td style="text-align:center;">.rel.data节</td> <td style="text-align:center;">被模块引用或定义的所有全局变量的重定位信息</td></tr> <tr><td style="text-align:center;">.debug节</td> <td style="text-align:center;">条目是局部变量、类型定义、全局变量及C源文件</td></tr> <tr><td style="text-align:center;">.line节</td> <td style="text-align:center;">原始 C 源程序的行号和.text 节中机器指令之间的映射</td></tr> <tr><td style="text-align:center;">.strtab节</td> <td style="text-align:center;">.symtab和.debug中符号表及节头部中节的名字</td></tr> <tr><td style="text-align:center;">节头表</td> <td style="text-align:center;">描述目标文件的节</td></tr></tbody></table> <p>表格 6 可重定位ELF格式结构</p> <h3 id="elf头分析"><a href="#elf头分析" class="header-anchor">#</a> ELF头分析</h3> <p>使用readelf可以看到hello.o可重定位文件的ELF头，如下：</p> <p><img src="image021.png" alt="图 20 hello.o的ELF头"></p> <p>各部分解释如下：</p> <table><thead><tr><th style="text-align:center;">项目</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">Magic</td> <td style="text-align:center;">用于确定文件的类型或格式</td></tr> <tr><td style="text-align:center;">Class： ELF64</td> <td style="text-align:center;">ELF64格式</td></tr> <tr><td style="text-align:center;">Data： 2's complement， little endian</td> <td style="text-align:center;">二进制补码格式，小端</td></tr> <tr><td style="text-align:center;">Version： 1 (current)</td> <td style="text-align:center;">版本信息Version</td></tr> <tr><td style="text-align:center;">OS/ABI： UNIX - System V</td> <td style="text-align:center;">操作系统UNIX - System V</td></tr> <tr><td style="text-align:center;">ABI Version： 0</td> <td style="text-align:center;">ABI版本</td></tr> <tr><td style="text-align:center;">Type： REL (Relocatable file)</td> <td style="text-align:center;">可重定位文件</td></tr> <tr><td style="text-align:center;">Machine： Advanced Micro Devices X86-64</td> <td style="text-align:center;">Advanced Micro Devices X86-64的机器</td></tr> <tr><td style="text-align:center;">Version： 0x1</td> <td style="text-align:center;">版本</td></tr> <tr><td style="text-align:center;">Entry point address： 0x0</td> <td style="text-align:center;">程序执行的入口地址</td></tr> <tr><td style="text-align:center;">Start of program headers： 0 (bytes into file)</td> <td style="text-align:center;">段头部表的开始</td></tr> <tr><td style="text-align:center;">Start of section headers： 1112 (bytes into file)</td> <td style="text-align:center;">节头部表的开始</td></tr> <tr><td style="text-align:center;">Flags： 0x0</td> <td style="text-align:center;">一个标志位</td></tr> <tr><td style="text-align:center;">Size of this header： 64 (bytes)</td> <td style="text-align:center;">ELF头大小</td></tr> <tr><td style="text-align:center;">Size of program headers： 0 (bytes)</td> <td style="text-align:center;">段头部表大小</td></tr> <tr><td style="text-align:center;">Number of program headers： 0</td> <td style="text-align:center;">几个段头部表（没有段头部表，所以大小和数量都是0）</td></tr> <tr><td style="text-align:center;">Size of section headers： 64 (bytes)</td> <td style="text-align:center;">节头部表大小</td></tr> <tr><td style="text-align:center;">Number of section headers： 13</td> <td style="text-align:center;">节头部表数量</td></tr> <tr><td style="text-align:center;">Section header string table index： 12</td> <td style="text-align:center;">字符串表在节头部表中的索引</td></tr></tbody></table> <h3 id="节头表分析"><a href="#节头表分析" class="header-anchor">#</a> 节头表分析</h3> <p>用readelf命令同样可以获得hello.o的节头表，如下：</p> <p><img src="image022.png" alt="图 21 hello.o的节头表"></p> <p>由于节数量较多，下表以.text节为例，列出了.text节的一些基本参数及其解释：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">意义</th> <th style="text-align:center;">值</th></tr></thead> <tbody><tr><td style="text-align:center;">Size</td> <td style="text-align:center;">大小</td> <td style="text-align:center;">0x80</td></tr> <tr><td style="text-align:center;">Offset</td> <td style="text-align:center;">偏移</td> <td style="text-align:center;">0x40</td></tr> <tr><td style="text-align:center;">Flag</td> <td style="text-align:center;">权限标志位</td> <td style="text-align:center;">AX(alloc + execute)</td></tr> <tr><td style="text-align:center;">Align</td> <td style="text-align:center;">对齐</td> <td style="text-align:center;">0x1</td></tr></tbody></table> <p>根据各个节的size、offset、align信息，可以画出各个节的内存位置图，如下：</p> <p><img src="image023.png" alt="图 22 hello.o各个节位置分布"></p> <p>同时，在输出结果中也可以看到，在链接之前的阶段，各个节的地址都是0x0，如图：</p> <p><img src="image024.png" alt="图 23 链接之前各个节首地址为0x0"></p> <h3 id="重定位节分析"><a href="#重定位节分析" class="header-anchor">#</a> 重定位节分析</h3> <p>readelf获得的重定位信息如下：</p> <p><img src="image025.png" alt="图 24 .rela.text节信息"></p> <p>此部分包含了链接时需要的重定位条目，各参数说明如下：</p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">Offset</td> <td style="text-align:center;">需要进行重定向的代码在.text或.data节中的偏移位置，8 个字节。</td></tr> <tr><td style="text-align:center;">Info</td> <td style="text-align:center;">包括 symbol 和 type 两部分，其中 symbol 占前 4 个字节，type 占后 4 个字节，symbol 代表重定位到的目标在.symtab中的偏移量，type 代表重定位的类型。</td></tr> <tr><td style="text-align:center;">Addend</td> <td style="text-align:center;">计算重定位位置的辅助信息，共占 8 个字节</td></tr> <tr><td style="text-align:center;">Type</td> <td style="text-align:center;">重定位到的目标的类型</td></tr> <tr><td style="text-align:center;">Name</td> <td style="text-align:center;">重定向到的目标的名称</td></tr></tbody></table> <h3 id="符号表分析"><a href="#符号表分析" class="header-anchor">#</a> 符号表分析</h3> <p>readelf获得的符号表如下：</p> <p><img src="image026.png" alt="图 25 .symtab节"></p> <p>符号表用来存放程序中定义和引用的函数和全局变量的信息。重定位时，需要引用的符号都在其中声明</p> <h2 id="hello-o的结果解析"><a href="#hello-o的结果解析" class="header-anchor">#</a> Hello.o的结果解析</h2> <p>使用objdump -d -r hello.o反汇编结果如下：</p> <p><img src="image027.png" alt="图 26 反汇编hello.o"></p> <p>可以看到，反汇编得到的代码和通过编译得到的代码有一定区别。</p> <ol><li>.s汇编代码会有一些指示汇编器的标签，用于标识一些信息，如下图标注部分：</li></ol> <p><img src="image028.png" alt="图 27 汇编文件不明标签"></p> <ol start="2"><li>分支转移</li></ol> <p>.s汇编代码用jXX .L2等跳转方式，即跳转一个标签；而反汇编代码跳转指令的操作数使用的不是标签而是相对地址，如&lt;main+0x29&gt;：</p> <p><img src="image029.png" alt="图 28 反汇编相对跳转"></p> <ol start="3"><li>函数调用</li></ol> <p>在.s 汇编代码中，函数调用之后直接跟着函数名称，比如call 和exit等。
而在反汇编程序中，hello.c 中调用的函数有些是共享库中的函数，需要在下一步通过动态链接器ld链接之后才能确定函数运行时的执行地址，汇编器把它们编译成机器语言的时候，对于不确定地址的函数调用会将其 call 指令后的相对地址设置为全 0（见图 28 反汇编相对跳转）此时反汇编将字节码翻译成汇编代码是无意义的，需要根据重定位条目在链接阶段进行修改。</p> <h2 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h2> <p>本章通过对于hello.s进行编译，获得hello.o文件，结合汇编的概念及作用分析了汇编对文本.s文件的相应处理，查看 hello.o 的 elf 格式并分析，详细地ELF头，重定位信息和节头部表的各部分详细含义，并对 objdump 得到的反汇编代码与 hello.s 进行比较，了解到从汇编语言映射到机器语言时汇编器需要实现的一些转换，并对结果进行了相应的解析。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">6/23/2021, 2:15:04 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ComputerSystemFinalWorkBlog/ch3.html" class="prev">
        第3章 编译
      </a></span> <span class="next"><a href="/ComputerSystemFinalWorkBlog/ch5.html">
        第5章 链接
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ComputerSystemFinalWorkBlog/assets/js/app.38facb16.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/2.5a7b0d16.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/13.3f64a882.js" defer></script>
  </body>
</html>
