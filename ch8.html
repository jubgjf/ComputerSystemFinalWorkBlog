<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第8章 hello的IO管理 | Guan Jiannan 的计算机系统大作业博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.16f4c5d5.css" as="style"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/app.1b5451d3.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/2.a04b7fc9.js" as="script"><link rel="preload" href="/ComputerSystemFinalWorkBlog/assets/js/17.e0fb3384.js" as="script"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/10.8c04925c.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/11.3b6f4125.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/12.f7378424.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/13.3f64a882.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/14.0dc1b3d6.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/15.145cf089.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/16.529c9f0a.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/18.68e4c5ab.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/3.5219c653.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/4.0ed284d6.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/5.8b64aaec.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/6.744a911e.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/7.efae4d63.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/8.58d5c346.js"><link rel="prefetch" href="/ComputerSystemFinalWorkBlog/assets/js/9.32b0a8f2.js">
    <link rel="stylesheet" href="/ComputerSystemFinalWorkBlog/assets/css/0.styles.16f4c5d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ComputerSystemFinalWorkBlog/" class="home-link router-link-active"><!----> <span class="site-name">Guan Jiannan 的计算机系统大作业博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>程序人生 - Hello’s P2P</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ComputerSystemFinalWorkBlog/" aria-current="page" class="sidebar-link">大作业说明</a></li><li><a href="/ComputerSystemFinalWorkBlog/abstract.html" class="sidebar-link">摘要</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch1.html" class="sidebar-link">第1章 概述</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch2.html" class="sidebar-link">第2章 预处理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch3.html" class="sidebar-link">第3章 编译</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch4.html" class="sidebar-link">第4章 汇编</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch5.html" class="sidebar-link">第5章 链接</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch6.html" class="sidebar-link">第6章 hello 进程管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch7.html" class="sidebar-link">第7章 hello 存储管理</a></li><li><a href="/ComputerSystemFinalWorkBlog/ch8.html" aria-current="page" class="active sidebar-link">第8章 hello IO 管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch8.html#linux的io设备管理方法" class="sidebar-link">Linux的IO设备管理方法</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch8.html#简述unix-io接口及其函数" class="sidebar-link">简述Unix IO接口及其函数</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch8.html#printf的实现分析" class="sidebar-link">printf的实现分析</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch8.html#getchar的实现分析" class="sidebar-link">getchar的实现分析</a></li><li class="sidebar-sub-header"><a href="/ComputerSystemFinalWorkBlog/ch8.html#本章小结" class="sidebar-link">本章小结</a></li></ul></li><li><a href="/ComputerSystemFinalWorkBlog/conclusion.html" class="sidebar-link">结论</a></li><li><a href="/ComputerSystemFinalWorkBlog/appendix.html" class="sidebar-link">附件</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第8章-hello的io管理"><a href="#第8章-hello的io管理" class="header-anchor">#</a> 第8章 hello的IO管理</h1> <h2 id="linux的io设备管理方法"><a href="#linux的io设备管理方法" class="header-anchor">#</a> Linux的IO设备管理方法</h2> <p>设备的模型化：所有的 IO 设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux 内核引出一个简单低级的应用接口，称为 Unix I/O。</p> <h2 id="简述unix-io接口及其函数"><a href="#简述unix-io接口及其函数" class="header-anchor">#</a> 简述Unix IO接口及其函数</h2> <h3 id="unix-io概述"><a href="#unix-io概述" class="header-anchor">#</a> Unix IO概述</h3> <p>每个Linux文件都有一个类型（type）来表明它在系统中的角色，包括：</p> <ol><li>普通文件： 包含任意数据</li> <li>目录： 一组链接文件的索引</li> <li>套接字： 用来与另一个进程进行跨网络通信的文件</li> <li>命名通道</li> <li>符号链接</li> <li>字符和块设备</li></ol> <h3 id="普通文件"><a href="#普通文件" class="header-anchor">#</a> 普通文件</h3> <p>普通文件包含任意数据。可以分为文本文件和二进制文件。文本文件是只包含 ASCII 或 Unicode字符的普通文件。二进制文件是所有其他文件，如目标文件， JPEG图像文件等。内核并不知道两者之间的区别。</p> <p>Linux文本文件是文本行的序列。文本行是一个字符序列，以一个新行符 (‘\n’)结束。新行符为 0xa，与 ASCII 的换行符 (LF) 是一样的回车换行。</p> <p>Mac 操作系统也是用0xa即 ‘\n’换行。</p> <p>Windows 和因特网络协议使用‘\r\n’ (0xd 0xa)回车换行。</p> <h3 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h3> <p>目录是包含一组链接的文件。每个链接将一个文件名映射到一个文件。每个目录至少含有两个条目：</p> <ol><li>. 是到该文件自身的链接</li> <li>.. 是到目录层次结构中父目录的链接</li></ol> <p>Unix中，目录为树状结构：</p> <p><img src="image108.png" alt="图 108 Unix树状目录结构"></p> <p>可以用tree命令查看当前目录下的树状结构：</p> <p><img src="image109.png" alt="图 109 tree命令"></p> <h3 id="unix-io-接口和函数"><a href="#unix-io-接口和函数" class="header-anchor">#</a> Unix IO 接口和函数</h3> <p>Unix I/O 包括如下接口：</p> <ol><li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。Shell 创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。</li> <li>改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置 k，初始为 0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行 seek，显式地将改变当前文件位置 k。</li> <li>读写文件：一个读操作就是从文件复制 n&gt;0 个字节到内存，从当前文件位置 k 开始，然后将 k 增加到 k+n，给定一个大小为 m 字节的而文件，当 k&gt;=m 时，触发 EOF。类似一个写操作就是从内存中复制 n&gt;0个字节到一个文件，从当前文件位置 k 开始，然后更新 k。</li> <li>关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。</li></ol> <p>Unix I/O 包括如下函数：</p> <ol><li>int open(char* filename，int flags，mode_t mode) ，进程通过调用 open 函数来打开一个存在的文件或是创建一个新文件的。open 函数将 filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags 参数指明了进程打算如何访问这个文件，mode 参数指定了新文件的访问权限位。</li> <li>int close(fd)，fd 是需要关闭的文件的描述符，close 返回操作结果。</li> <li>ssize_t read(int fd，void *buf，size_t n)，read 函数从描述符为 fd 的当前文件位置赋值最多 n 个字节到内存位置 buf。返回值-1 表示一个错误，0表示 EOF，否则返回值表示的是实际传送的字节数量。</li> <li>ssize_t wirte(int fd，const void *buf，size_t n)，write 函数从内存位置 buf复制至多 n 个字节到描述符为 fd 的当前文件位置。</li></ol> <h2 id="printf的实现分析"><a href="#printf的实现分析" class="header-anchor">#</a> printf的实现分析</h2> <p>printf的实现如下：</p> <p><img src="image110.png" alt="图 110 printf实现"></p> <p>注意到在参数中最后边的省略号...，这个是可变形参的一种写法，当传递参数的个数不确定时，就可以用这种方式来表示。
(char*)(&amp;fmt) + 4) 表示的是...可变参数中的第一个参数的地址。而vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。vsprintf的实现如下：</p> <p><img src="image111.png" alt="图 111 vsprintf的简单实现"></p> <p>下一步printf调用write系统函数，在write中使用陷阱，通过系统调用syscall跳转到序号为1的sys_write入口点。下图为<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener noreferrer">Linux Kernel<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>为5.10.16.3版本的系统调用表中的前几项：</p> <p><img src="image112.png" alt="图 112 几个系统调用"></p> <p>接下来，字符显示驱动子程序根据ASCII码，从字模库中提取相应字符的点阵，存储到vram中，同时也存储每一个点的RGB颜色信息。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点，实现显示字符。</p> <h2 id="getchar的实现分析"><a href="#getchar的实现分析" class="header-anchor">#</a> getchar的实现分析</h2> <p>getchar的实现如下：</p> <p><img src="image113.png" alt="图 113 getchar的实现"></p> <p>getchar函数通过调用read函数返回字符。其中read函数的第一个参数是描述符fd，0代表标准输入。第二个参数输入内容的指针，这里也就是字符c的地址，最后一个参数是1，代表读入一个字符，符号getchar函数读一个字符的设定。read函数的返回值是读入的字符数，如果为1说明读入成功，那么直接返回字符，否则说明读到了buf的最后。
read函数同样通过sys_call中断来调用内核中的系统函数。键盘中断处理子程序会接受按键扫描码并将其转换为ASCII码后保存在缓冲区。然后read函数调用的系统函数可以对缓冲区ASCII码进行读取，直到接受回车键返回。
这样，getchar函数通过read函数返回字符，实现了读取一个字符的功能。</p> <h2 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h2> <p>本章介绍了Unix是如何将I/O设备模型化文件并统一处理的，同时详细介绍了Unix I/O函数，并对标准I/O函数printf和getchar的实现进行了分析：标准I/O函数的实现都调用了系统的I/O函数，通过中断指令将程序控制权交给系统内核，进行相应的中断处理，然后对硬件进行相应操作。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">9/25/2021, 4:41:50 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ComputerSystemFinalWorkBlog/ch7.html" class="prev">
        第7章 hello 存储管理
      </a></span> <span class="next"><a href="/ComputerSystemFinalWorkBlog/conclusion.html">
        结论
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ComputerSystemFinalWorkBlog/assets/js/app.1b5451d3.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/2.a04b7fc9.js" defer></script><script src="/ComputerSystemFinalWorkBlog/assets/js/17.e0fb3384.js" defer></script>
  </body>
</html>
